This repository contains build scripts and filesystem skeletons for
bootable minibase images based on Buildroot. When built, the images
will contain just enough to run X, Weston and (if the hardware is there)
connect to a wifi network.

The images should be bootable with qemu as well as with reasonably recent
x86_64 hardware with Intel graphics (and preferably iwlwifi wireless card).


Pre-built images
~~~~~~~~~~~~~~~~
Non-encrypted system is available as a ready-to-run image.

  https://github.com/arsv/minibase-br/releases

Download sys-plain.tar.bz2 and skip to "Booting with qemu" below.

The other archive there, "prebuilt.tar.bz2", contains pre-populated
buildroot/output/target and buildroot/output/images directories.
Follow the build intructions below but skip the Buildroot part.


System contents
~~~~~~~~~~~~~~~
The resulting images contain
	
	* ~3MB kernel
	* ~6MB of kernel modules
	* ~9MB of firmware blobs for iwlwifi
	* ~650KB of minibase tools

	* ~600KB musl (not needed for minibase)
	* ~200KB dropbear

	* about 30MB of weston and its dependencies
	* about 7MB atop of that for xwayland support
	* over 40MB of X

During the boot, `xorg`, and `dropbear` are the first executables
to load libc. Everything else up to the point when the system can
run `xorg` is handled by statically linked minibase tools.


Prerequisites
~~~~~~~~~~~~~
The host system need a usable GNU toolchain:

	* common POSIX tools
	* binutils, gcc, make
	* wget to download the sources

and also

	* mtools
	* syslinux, with files in /usr/share/syslinux
	  (tweak the scripts if the files are in another location)

Buildroot could be used to build both, but most system have them as packages
anyway so why bother.


How to build the images
~~~~~~~~~~~~~~~~~~~~~~~
Download https://buildroot.org/downloads/buildroot-2017.08.tar.bz2,
unpack it and rename the directory into ./buildroot.

# If the host system runs glibc-2.26:
#
#	cp brvendor/package/flex/0002*.patch buildroot/package/flex/
#
# otherwise the build will fail.

Update ./minibase and build it:

	git submodule update --init
	cd minibase
	./configure
	make
	make install    # this will install into ./out

Build the rest of the buildroot system
(skip this if working with the pre-built package):

	cd buildroot
	make BR2_EXTERNAL=../brvendor minibase_defconfig
	make            # this will take lots of time

Assemble plaintext image:

	cd sys-1-plain
	make

Assemble encrypted image:

	cd sys-2-crypt
	make

The first sys-crypt build will generate image encryptions keys which will
then be re-used unless removed manually. The tool will ask for passphrase
when generating the keys, and then once again to unwrap the keys when
encrypting the image. Any subsequent run will only ask for passphrase to
unwrap the keys.


System structure
~~~~~~~~~~~~~~~~
At the end of the build, the complete contents of initrd, bootfs and rootfs
will be in respective directories. Feel free to investigate them.

The kernel invokes initrd/init on startup. That script in turn execs into
rootfs/sbin/system/start which is a script as well.

The rootfs images are assembled by merging the contents of minibase/out,
buildroot/output/target, and rootfs-dropin. Initrds use minibase binaries
and the contents of either sys-crypt/boot or sys-plain/boot.


Booting with qemu
~~~~~~~~~~~~~~~~~
Run xqemu.sh in respective directories:

	cd sys-1-plain
	./xqemu.sh

The scripts will attempt to run qemu with -enable-kvm.

The password for sys-2-crypt is "swordfish".


Booting with real hardware
~~~~~~~~~~~~~~~~~~~~~~~~~~
Write the image onto usb stick:

	cd sys-1-plain
	dd if=whole.img of=/dev/sdb   # make sure it's the right device

and try to persuade the box to boot from that.

The image should be both BIOS and UEFI bootable on x86_64 hardware.
Mixed-mode UEFI (32-bit UEFI on 64-bit CPU) may or may not work.

There is absolutely nothing minibase-specific about booting the system,
any configuration that will get the kernel and initrd into the memory
should work. Feel free to experiment.

The system uses MBR ID 0x11223344 to find its boot media.


Getting around the system
~~~~~~~~~~~~~~~~~~~~~~~~~
The system is configured to be usable in qemu. VT switch combos are C-Fx,
not C-A-Fx as usual.

The system should boot into X/Fluxbox running on VT3. Tap C-F4 or C-F5
to switch to one of the Weston instances (starting it if necessary).
Tap C-F2 for a root console.

There's another root console on ttyS0 (serial).
In qemu, press C-A-3 to access it.

Use `svctl` to query top-level supervisor:

	svctl                  # process list
	svctl stop udevmod
	svctl start udevmod
	svctl poweroff

	svctl show keymon      # properly running service
	svctl show badsrv      # failed service

Use `vtctl` to control vtmux:

	vtctl 4                # switch to VT4

Use `wictl` to scan/connect to network:

	wifi scan              # scan wifi
	wifi connect blackhole # ask passphrase and connect to a named AP

The above only works if there are any wifi devices available.
Wired interfaces may be queries and initialized using ifctl:

	ifctl                  # show networking devices
	ifctl -a [dev]         # bring up and dhpc dev

These commands may come handy as well:

	logcat                 # syslog contents
	pstree                 # processes

Tap C-Esc to bring up the greeter VT. Shift-R to reboot, Shift-P to poweroff.

If running on real hardware, press C-Power to power the system off, and hold
C-A-Del for about a second to reboot.


Troubleshooting and caveats
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Errors at "Waiting for devices" stage indicate lack of necessary modules,
especially USB-related.

Weston may fail to start, showing blank screen and not reacting to inputs.
No idea what causes this yet.

Weston degrades into unusable mess when running in non-KVM qemu. Apparently
the slow emulated CPU breaks some frame sync assumptions. Without KVM, it may
also take something like 5+ seconds to start, showing blank screen in process.

While the kernel is modular, the supplied configuration only includes modules
for the stuff I have at hand (Intel based laptops). Feel free to reconfigure
if necessary. Sadly enabling everything is not an option for a system that aims
to be "small" in any sense of the word.

No wireless interfaces on HW with a supported Intel card likely likely means
no firmware for this particular card. Try to figure out which file it needs,
and drop it to /lib/firmware.
